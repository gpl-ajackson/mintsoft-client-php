<?php
/**
 * WarehouseApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.47-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Mintsoft;

use DateTime;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Promise\PromiseInterface;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Query;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use InvalidArgumentException;
use RuntimeException;
use stdClass;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\Model\MintsoftCommonToolkitResult;
use Swagger\Client\Model\MintsoftStockWarehouse;
use Swagger\Client\Model\MintsoftWarehouseAPIDTOStockMovementDTO;
use Swagger\Client\Model\MintsoftWarehouseAPIWarehouseTransfer;
use Swagger\Client\Model\MintsoftWarehouseBookStockRequest;
use Swagger\Client\Model\MintsoftWarehouseLocation;
use Swagger\Client\Model\MintsoftWarehouseLocationType;
use Swagger\Client\Model\MintsoftWarehouseToReturnWarehouseTransfer;
use Swagger\Client\Model\MintsoftWarehouseWarehouseTransfer;
use Swagger\Client\Model\MintsoftWarehouseZone;
use Swagger\Client\ObjectSerializer;

/**
 * WarehouseApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class WarehouseApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation warehouseBulkStockMovement
     *
     * @param  int $action action (required)
     * @param  MintsoftWarehouseBookStockRequest[] $requests requests (required)
     *
     * @return MintsoftCommonToolkitResult[]
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseBulkStockMovement($action, $requests)
    {
        list($response) = $this->warehouseBulkStockMovementWithHttpInfo($action, $requests);
        return $response;
    }

    /**
     * Operation warehouseBulkStockMovementWithHttpInfo
     *
     * @param  int $action (required)
     * @param  MintsoftWarehouseBookStockRequest[] $requests (required)
     *
     * @return array of \Swagger\Client\Model\MintsoftCommonToolkitResult[], HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseBulkStockMovementWithHttpInfo($action, $requests)
    {
        $returnType = '\Swagger\Client\Model\MintsoftCommonToolkitResult[]';
        $request = $this->warehouseBulkStockMovementRequest($action, $requests);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftCommonToolkitResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseBulkStockMovementAsync
     *
     * 
     *
     * @param  int $action (required)
     * @param  MintsoftWarehouseBookStockRequest[] $requests (required)
     *
     * @return PromiseInterface
     *@throws InvalidArgumentException
     */
    public function warehouseBulkStockMovementAsync($action, $requests)
    {
        return $this->warehouseBulkStockMovementAsyncWithHttpInfo($action, $requests)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseBulkStockMovementAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $action (required)
     * @param  MintsoftWarehouseBookStockRequest[] $requests (required)
     *
     * @return PromiseInterface
     *@throws InvalidArgumentException
     */
    public function warehouseBulkStockMovementAsyncWithHttpInfo($action, $requests)
    {
        $returnType = '\Swagger\Client\Model\MintsoftCommonToolkitResult[]';
        $request = $this->warehouseBulkStockMovementRequest($action, $requests);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseBulkStockMovement'
     *
     * @param  int $action (required)
     * @param  MintsoftWarehouseBookStockRequest[] $requests (required)
     *
     * @return Request
     *@throws InvalidArgumentException
     */
    protected function warehouseBulkStockMovementRequest($action, $requests)
    {
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $action when calling warehouseBulkStockMovement'
            );
        }
        // verify the required parameter 'requests' is set
        if ($requests === null || (is_array($requests) && count($requests) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $requests when calling warehouseBulkStockMovement'
            );
        }

        $resourcePath = '/api/Warehouse/BulkStockMovement';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($action !== null) {
            $queryParams['Action'] = ObjectSerializer::toQueryValue($action);
        }


        // body params
        $_tempBody = null;
        if (isset($requests)) {
            $_tempBody = $requests;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseCancelWarehouseTransfer
     *
     * Cancel WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @return MintsoftCommonToolkitResult
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseCancelWarehouseTransfer($id)
    {
        list($response) = $this->warehouseCancelWarehouseTransferWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation warehouseCancelWarehouseTransferWithHttpInfo
     *
     * Cancel WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @return array of \Swagger\Client\Model\MintsoftCommonToolkitResult, HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseCancelWarehouseTransferWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\MintsoftCommonToolkitResult';
        $request = $this->warehouseCancelWarehouseTransferRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftCommonToolkitResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseCancelWarehouseTransferAsync
     *
     * Cancel WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseCancelWarehouseTransferAsync($id)
    {
        return $this->warehouseCancelWarehouseTransferAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseCancelWarehouseTransferAsyncWithHttpInfo
     *
     * Cancel WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseCancelWarehouseTransferAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\MintsoftCommonToolkitResult';
        $request = $this->warehouseCancelWarehouseTransferRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseCancelWarehouseTransfer'
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @return Request
     *@throws InvalidArgumentException
     */
    protected function warehouseCancelWarehouseTransferRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling warehouseCancelWarehouseTransfer'
            );
        }

        $resourcePath = '/api/WarehouseTransfer/{id}/Cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseConfirmWarehouseTransfer
     *
     * Confirm WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @return MintsoftCommonToolkitResult
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseConfirmWarehouseTransfer($id)
    {
        list($response) = $this->warehouseConfirmWarehouseTransferWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation warehouseConfirmWarehouseTransferWithHttpInfo
     *
     * Confirm WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @return array of \Swagger\Client\Model\MintsoftCommonToolkitResult, HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseConfirmWarehouseTransferWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\MintsoftCommonToolkitResult';
        $request = $this->warehouseConfirmWarehouseTransferRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftCommonToolkitResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseConfirmWarehouseTransferAsync
     *
     * Confirm WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseConfirmWarehouseTransferAsync($id)
    {
        return $this->warehouseConfirmWarehouseTransferAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseConfirmWarehouseTransferAsyncWithHttpInfo
     *
     * Confirm WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseConfirmWarehouseTransferAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\MintsoftCommonToolkitResult';
        $request = $this->warehouseConfirmWarehouseTransferRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseConfirmWarehouseTransfer'
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @return Request
     *@throws InvalidArgumentException
     */
    protected function warehouseConfirmWarehouseTransferRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling warehouseConfirmWarehouseTransfer'
            );
        }

        $resourcePath = '/api/WarehouseTransfer/{id}/Confirm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseCreateWarehouseTransfer
     *
     * Create new WarehouseTransfer
     *
     * @param  MintsoftWarehouseAPIWarehouseTransfer $warehouse_transfer WarehouseTransfer Json in the Body of the request (required)
     *
     * @return MintsoftCommonToolkitResult
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseCreateWarehouseTransfer($warehouse_transfer)
    {
        list($response) = $this->warehouseCreateWarehouseTransferWithHttpInfo($warehouse_transfer);
        return $response;
    }

    /**
     * Operation warehouseCreateWarehouseTransferWithHttpInfo
     *
     * Create new WarehouseTransfer
     *
     * @param  MintsoftWarehouseAPIWarehouseTransfer $warehouse_transfer WarehouseTransfer Json in the Body of the request (required)
     *
     * @return array of \Swagger\Client\Model\MintsoftCommonToolkitResult, HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseCreateWarehouseTransferWithHttpInfo($warehouse_transfer)
    {
        $returnType = '\Swagger\Client\Model\MintsoftCommonToolkitResult';
        $request = $this->warehouseCreateWarehouseTransferRequest($warehouse_transfer);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftCommonToolkitResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseCreateWarehouseTransferAsync
     *
     * Create new WarehouseTransfer
     *
     * @param  MintsoftWarehouseAPIWarehouseTransfer $warehouse_transfer WarehouseTransfer Json in the Body of the request (required)
     *
     * @return PromiseInterface
     *@throws InvalidArgumentException
     */
    public function warehouseCreateWarehouseTransferAsync($warehouse_transfer)
    {
        return $this->warehouseCreateWarehouseTransferAsyncWithHttpInfo($warehouse_transfer)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseCreateWarehouseTransferAsyncWithHttpInfo
     *
     * Create new WarehouseTransfer
     *
     * @param  MintsoftWarehouseAPIWarehouseTransfer $warehouse_transfer WarehouseTransfer Json in the Body of the request (required)
     *
     * @return PromiseInterface
     *@throws InvalidArgumentException
     */
    public function warehouseCreateWarehouseTransferAsyncWithHttpInfo($warehouse_transfer)
    {
        $returnType = '\Swagger\Client\Model\MintsoftCommonToolkitResult';
        $request = $this->warehouseCreateWarehouseTransferRequest($warehouse_transfer);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseCreateWarehouseTransfer'
     *
     * @param  MintsoftWarehouseAPIWarehouseTransfer $warehouse_transfer WarehouseTransfer Json in the Body of the request (required)
     *
     * @return Request
     *@throws InvalidArgumentException
     */
    protected function warehouseCreateWarehouseTransferRequest($warehouse_transfer)
    {
        // verify the required parameter 'warehouse_transfer' is set
        if ($warehouse_transfer === null || (is_array($warehouse_transfer) && count($warehouse_transfer) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_transfer when calling warehouseCreateWarehouseTransfer'
            );
        }

        $resourcePath = '/api/WarehouseTransfer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($warehouse_transfer)) {
            $_tempBody = $warehouse_transfer;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseDeleteWarehouseTransfer
     *
     * Delete WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @return MintsoftCommonToolkitResult
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseDeleteWarehouseTransfer($id)
    {
        list($response) = $this->warehouseDeleteWarehouseTransferWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation warehouseDeleteWarehouseTransferWithHttpInfo
     *
     * Delete WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @return array of \Swagger\Client\Model\MintsoftCommonToolkitResult, HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseDeleteWarehouseTransferWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\MintsoftCommonToolkitResult';
        $request = $this->warehouseDeleteWarehouseTransferRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftCommonToolkitResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseDeleteWarehouseTransferAsync
     *
     * Delete WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseDeleteWarehouseTransferAsync($id)
    {
        return $this->warehouseDeleteWarehouseTransferAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseDeleteWarehouseTransferAsyncWithHttpInfo
     *
     * Delete WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseDeleteWarehouseTransferAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\MintsoftCommonToolkitResult';
        $request = $this->warehouseDeleteWarehouseTransferRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseDeleteWarehouseTransfer'
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @return Request
     *@throws InvalidArgumentException
     */
    protected function warehouseDeleteWarehouseTransferRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling warehouseDeleteWarehouseTransfer'
            );
        }

        $resourcePath = '/api/WarehouseTransfer/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseGetLocation
     *
     * @param  int $warehouse_id warehouse_id (required)
     * @param  int $location_id location_id (required)
     *
     * @return MintsoftWarehouseLocation
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseGetLocation($warehouse_id, $location_id)
    {
        list($response) = $this->warehouseGetLocationWithHttpInfo($warehouse_id, $location_id);
        return $response;
    }

    /**
     * Operation warehouseGetLocationWithHttpInfo
     *
     * @param  int $warehouse_id (required)
     * @param  int $location_id (required)
     *
     * @return array of \Swagger\Client\Model\MintsoftWarehouseLocation, HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseGetLocationWithHttpInfo($warehouse_id, $location_id)
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseLocation';
        $request = $this->warehouseGetLocationRequest($warehouse_id, $location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftWarehouseLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseGetLocationAsync
     *
     * 
     *
     * @param  int $warehouse_id (required)
     * @param  int $location_id (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseGetLocationAsync($warehouse_id, $location_id)
    {
        return $this->warehouseGetLocationAsyncWithHttpInfo($warehouse_id, $location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseGetLocationAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $warehouse_id (required)
     * @param  int $location_id (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseGetLocationAsyncWithHttpInfo($warehouse_id, $location_id)
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseLocation';
        $request = $this->warehouseGetLocationRequest($warehouse_id, $location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseGetLocation'
     *
     * @param  int $warehouse_id (required)
     * @param  int $location_id (required)
     *
     * @return Request
     *@throws InvalidArgumentException
     */
    protected function warehouseGetLocationRequest($warehouse_id, $location_id)
    {
        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling warehouseGetLocation'
            );
        }
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling warehouseGetLocation'
            );
        }

        $resourcePath = '/api/Warehouse/{WarehouseId}/Location/{LocationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'WarehouseId' . '}',
                ObjectSerializer::toPathValue($warehouse_id),
                $resourcePath
            );
        }
        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'LocationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseGetLocationTypes
     *
     *
     * @return MintsoftWarehouseLocationType[]
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseGetLocationTypes()
    {
        list($response) = $this->warehouseGetLocationTypesWithHttpInfo();
        return $response;
    }

    /**
     * Operation warehouseGetLocationTypesWithHttpInfo
     *
     *
     * @return array of \Swagger\Client\Model\MintsoftWarehouseLocationType[], HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseGetLocationTypesWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseLocationType[]';
        $request = $this->warehouseGetLocationTypesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftWarehouseLocationType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseGetLocationTypesAsync
     *
     * 
     *
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseGetLocationTypesAsync()
    {
        return $this->warehouseGetLocationTypesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseGetLocationTypesAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseGetLocationTypesAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseLocationType[]';
        $request = $this->warehouseGetLocationTypesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseGetLocationTypes'
     *
     *
     * @return Request
     *@throws InvalidArgumentException
     */
    protected function warehouseGetLocationTypesRequest()
    {

        $resourcePath = '/api/Warehouse/LocationTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseGetLocations
     *
     * @param  int $warehouse_id warehouse_id (required)
     * @param  bool $include_un_assigned include_un_assigned (optional)
     *
     * @return array
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseGetLocations($warehouse_id, $include_un_assigned = null)
    {
        list($response) = $this->warehouseGetLocationsWithHttpInfo($warehouse_id, $include_un_assigned);
        return $response;
    }

    /**
     * Operation warehouseGetLocationsWithHttpInfo
     *
     * @param  int $warehouse_id (required)
     * @param  bool $include_un_assigned (optional)
     *
     * @return array of \Swagger\Client\Model\MintsoftWarehouseLocation[], HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseGetLocationsWithHttpInfo($warehouse_id, $include_un_assigned = null)
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseLocation[]';
        $request = $this->warehouseGetLocationsRequest($warehouse_id, $include_un_assigned);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftWarehouseLocation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseGetLocationsAsync
     *
     * 
     *
     * @param  int $warehouse_id (required)
     * @param  bool $include_un_assigned (optional)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseGetLocationsAsync($warehouse_id, $include_un_assigned = null)
    {
        return $this->warehouseGetLocationsAsyncWithHttpInfo($warehouse_id, $include_un_assigned)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseGetLocationsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $warehouse_id (required)
     * @param  bool $include_un_assigned (optional)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseGetLocationsAsyncWithHttpInfo($warehouse_id, $include_un_assigned = null)
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseLocation[]';
        $request = $this->warehouseGetLocationsRequest($warehouse_id, $include_un_assigned);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseGetLocations'
     *
     * @param  int $warehouse_id (required)
     * @param  bool $include_un_assigned (optional)
     *
     * @return Request
     *@throws InvalidArgumentException
     */
    protected function warehouseGetLocationsRequest($warehouse_id, $include_un_assigned = null)
    {
        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling warehouseGetLocations'
            );
        }

        $resourcePath = '/api/Warehouse/{WarehouseId}/Location/All';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_un_assigned !== null) {
            $queryParams['IncludeUnAssigned'] = ObjectSerializer::toQueryValue($include_un_assigned);
        }

        // path params
        if ($warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'WarehouseId' . '}',
                ObjectSerializer::toPathValue($warehouse_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseGetStatuses
     *
     * Get WarehouseTransfer Statuses
     *
     *
     * @return string[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseGetStatuses()
    {
        list($response) = $this->warehouseGetStatusesWithHttpInfo();
        return $response;
    }

    /**
     * Operation warehouseGetStatusesWithHttpInfo
     *
     * Get WarehouseTransfer Statuses
     *
     *
     * @return array of string[], HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseGetStatusesWithHttpInfo()
    {
        $returnType = 'string[]';
        $request = $this->warehouseGetStatusesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseGetStatusesAsync
     *
     * Get WarehouseTransfer Statuses
     *
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseGetStatusesAsync()
    {
        return $this->warehouseGetStatusesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseGetStatusesAsyncWithHttpInfo
     *
     * Get WarehouseTransfer Statuses
     *
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseGetStatusesAsyncWithHttpInfo()
    {
        $returnType = 'string[]';
        $request = $this->warehouseGetStatusesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseGetStatuses'
     *
     *
     * @return Request
     *@throws InvalidArgumentException
     */
    protected function warehouseGetStatusesRequest()
    {

        $resourcePath = '/api/WarehouseTransfer/Statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseGetWarehouseTransfer
     *
     * Get WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @return MintsoftWarehouseWarehouseTransfer
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseGetWarehouseTransfer($id)
    {
        list($response) = $this->warehouseGetWarehouseTransferWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation warehouseGetWarehouseTransferWithHttpInfo
     *
     * Get WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @return array of \Swagger\Client\Model\MintsoftWarehouseWarehouseTransfer, HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseGetWarehouseTransferWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseWarehouseTransfer';
        $request = $this->warehouseGetWarehouseTransferRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftWarehouseWarehouseTransfer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseGetWarehouseTransferAsync
     *
     * Get WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseGetWarehouseTransferAsync($id)
    {
        return $this->warehouseGetWarehouseTransferAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseGetWarehouseTransferAsyncWithHttpInfo
     *
     * Get WarehouseTransfer
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseGetWarehouseTransferAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseWarehouseTransfer';
        $request = $this->warehouseGetWarehouseTransferRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseGetWarehouseTransfer'
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     *
     * @return Request
     *@throws InvalidArgumentException
     */
    protected function warehouseGetWarehouseTransferRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling warehouseGetWarehouseTransfer'
            );
        }

        $resourcePath = '/api/WarehouseTransfer/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseGetWarehouseZones
     *
     * @param  int $id id (required)
     *
     * @return MintsoftWarehouseZone[]
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseGetWarehouseZones($id)
    {
        list($response) = $this->warehouseGetWarehouseZonesWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation warehouseGetWarehouseZonesWithHttpInfo
     *
     * @param  int $id (required)
     *
     * @return array of \Swagger\Client\Model\MintsoftWarehouseZone[], HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseGetWarehouseZonesWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseZone[]';
        $request = $this->warehouseGetWarehouseZonesRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftWarehouseZone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseGetWarehouseZonesAsync
     *
     * 
     *
     * @param  int $id (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseGetWarehouseZonesAsync($id)
    {
        return $this->warehouseGetWarehouseZonesAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseGetWarehouseZonesAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $id (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseGetWarehouseZonesAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseZone[]';
        $request = $this->warehouseGetWarehouseZonesRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseGetWarehouseZones'
     *
     * @param  int $id (required)
     *
     * @return Request
     *@throws InvalidArgumentException
     */
    protected function warehouseGetWarehouseZonesRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling warehouseGetWarehouseZones'
            );
        }

        $resourcePath = '/api/Warehouse/{id}/Zones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseGetWarehouses
     *
     *
     * @return MintsoftStockWarehouse[]
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseGetWarehouses()
    {
        list($response) = $this->warehouseGetWarehousesWithHttpInfo();
        return $response;
    }

    /**
     * Operation warehouseGetWarehousesWithHttpInfo
     *
     *
     * @return array of \Swagger\Client\Model\MintsoftStockWarehouse[], HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseGetWarehousesWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\MintsoftStockWarehouse[]';
        $request = $this->warehouseGetWarehousesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftStockWarehouse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseGetWarehousesAsync
     *
     * 
     *
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseGetWarehousesAsync()
    {
        return $this->warehouseGetWarehousesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseGetWarehousesAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseGetWarehousesAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\MintsoftStockWarehouse[]';
        $request = $this->warehouseGetWarehousesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseGetWarehouses'
     *
     *
     * @throws InvalidArgumentException
     * @return Request
     */
    protected function warehouseGetWarehousesRequest()
    {

        $resourcePath = '/api/Warehouse';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseListWarehouseTransfers
     *
     * @param  bool $include_warehouse_transfer_items include_warehouse_transfer_items (optional)
     * @param  string $warehouse_transfer_statuses warehouse_transfer_statuses (optional)
     * @param  int $page_no page_no (optional)
     * @param  int $limit limit (optional)
     * @param  int $client_id client_id (optional)
     * @param  int $source_warehouse_id source_warehouse_id (optional)
     * @param  int $destination_warehouse_id destination_warehouse_id (optional)
     * @param  DateTime $since_last_updated since_last_updated (optional)
     *
     * @return MintsoftWarehouseToReturnWarehouseTransfer[]
     *@throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     */
    public function warehouseListWarehouseTransfers($include_warehouse_transfer_items = null, $warehouse_transfer_statuses = null, $page_no = null, $limit = null, $client_id = null, $source_warehouse_id = null, $destination_warehouse_id = null, $since_last_updated = null)
    {
        list($response) = $this->warehouseListWarehouseTransfersWithHttpInfo($include_warehouse_transfer_items, $warehouse_transfer_statuses, $page_no, $limit, $client_id, $source_warehouse_id, $destination_warehouse_id, $since_last_updated);
        return $response;
    }

    /**
     * Operation warehouseListWarehouseTransfersWithHttpInfo
     *
     * @param  bool $include_warehouse_transfer_items (optional)
     * @param  string $warehouse_transfer_statuses (optional)
     * @param  int $page_no (optional)
     * @param  int $limit (optional)
     * @param  int $client_id (optional)
     * @param  int $source_warehouse_id (optional)
     * @param  int $destination_warehouse_id (optional)
     * @param  DateTime $since_last_updated (optional)
     *
     * @return array of \Swagger\Client\Model\MintsoftWarehouseToReturnWarehouseTransfer[], HTTP status code, HTTP response headers (array of strings)
     *@throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     */
    public function warehouseListWarehouseTransfersWithHttpInfo($include_warehouse_transfer_items = null, $warehouse_transfer_statuses = null, $page_no = null, $limit = null, $client_id = null, $source_warehouse_id = null, $destination_warehouse_id = null, $since_last_updated = null)
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseToReturnWarehouseTransfer[]';
        $request = $this->warehouseListWarehouseTransfersRequest($include_warehouse_transfer_items, $warehouse_transfer_statuses, $page_no, $limit, $client_id, $source_warehouse_id, $destination_warehouse_id, $since_last_updated);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftWarehouseToReturnWarehouseTransfer[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseListWarehouseTransfersAsync
     *
     * 
     *
     * @param  bool $include_warehouse_transfer_items (optional)
     * @param  string $warehouse_transfer_statuses (optional)
     * @param  int $page_no (optional)
     * @param  int $limit (optional)
     * @param  int $client_id (optional)
     * @param  int $source_warehouse_id (optional)
     * @param  int $destination_warehouse_id (optional)
     * @param  DateTime $since_last_updated (optional)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseListWarehouseTransfersAsync($include_warehouse_transfer_items = null, $warehouse_transfer_statuses = null, $page_no = null, $limit = null, $client_id = null, $source_warehouse_id = null, $destination_warehouse_id = null, $since_last_updated = null)
    {
        return $this->warehouseListWarehouseTransfersAsyncWithHttpInfo($include_warehouse_transfer_items, $warehouse_transfer_statuses, $page_no, $limit, $client_id, $source_warehouse_id, $destination_warehouse_id, $since_last_updated)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseListWarehouseTransfersAsyncWithHttpInfo
     *
     * 
     *
     * @param  bool $include_warehouse_transfer_items (optional)
     * @param  string $warehouse_transfer_statuses (optional)
     * @param  int $page_no (optional)
     * @param  int $limit (optional)
     * @param  int $client_id (optional)
     * @param  int $source_warehouse_id (optional)
     * @param  int $destination_warehouse_id (optional)
     * @param  DateTime $since_last_updated (optional)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseListWarehouseTransfersAsyncWithHttpInfo($include_warehouse_transfer_items = null, $warehouse_transfer_statuses = null, $page_no = null, $limit = null, $client_id = null, $source_warehouse_id = null, $destination_warehouse_id = null, $since_last_updated = null)
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseToReturnWarehouseTransfer[]';
        $request = $this->warehouseListWarehouseTransfersRequest($include_warehouse_transfer_items, $warehouse_transfer_statuses, $page_no, $limit, $client_id, $source_warehouse_id, $destination_warehouse_id, $since_last_updated);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseListWarehouseTransfers'
     *
     * @param  bool $include_warehouse_transfer_items (optional)
     * @param  string $warehouse_transfer_statuses (optional)
     * @param  int $page_no (optional)
     * @param  int $limit (optional)
     * @param  int $client_id (optional)
     * @param  int $source_warehouse_id (optional)
     * @param  int $destination_warehouse_id (optional)
     * @param  DateTime $since_last_updated (optional)
     *
     * @throws InvalidArgumentException
     * @return Request
     */
    protected function warehouseListWarehouseTransfersRequest($include_warehouse_transfer_items = null, $warehouse_transfer_statuses = null, $page_no = null, $limit = null, $client_id = null, $source_warehouse_id = null, $destination_warehouse_id = null, $since_last_updated = null)
    {

        $resourcePath = '/api/WarehouseTransfer/List';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_warehouse_transfer_items !== null) {
            $queryParams['IncludeWarehouseTransferItems'] = ObjectSerializer::toQueryValue($include_warehouse_transfer_items);
        }
        // query params
        if ($warehouse_transfer_statuses !== null) {
            $queryParams['WarehouseTransferStatuses'] = ObjectSerializer::toQueryValue($warehouse_transfer_statuses);
        }
        // query params
        if ($page_no !== null) {
            $queryParams['PageNo'] = ObjectSerializer::toQueryValue($page_no);
        }
        // query params
        if ($limit !== null) {
            $queryParams['Limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['ClientId'] = ObjectSerializer::toQueryValue($client_id);
        }
        // query params
        if ($source_warehouse_id !== null) {
            $queryParams['SourceWarehouseId'] = ObjectSerializer::toQueryValue($source_warehouse_id);
        }
        // query params
        if ($destination_warehouse_id !== null) {
            $queryParams['DestinationWarehouseId'] = ObjectSerializer::toQueryValue($destination_warehouse_id);
        }
        // query params
        if ($since_last_updated !== null) {
            $queryParams['SinceLastUpdated'] = ObjectSerializer::toQueryValue($since_last_updated);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseLookupLocationId
     *
     * @param  int $warehouse_id warehouse_id (required)
     * @param  string $location location (required)
     *
     * @return MintsoftWarehouseLocation
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseLookupLocationId($warehouse_id, $location)
    {
        list($response) = $this->warehouseLookupLocationIdWithHttpInfo($warehouse_id, $location);
        return $response;
    }

    /**
     * Operation warehouseLookupLocationIdWithHttpInfo
     *
     * @param  int $warehouse_id (required)
     * @param  string $location (required)
     *
     * @return array of \Swagger\Client\Model\MintsoftWarehouseLocation, HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseLookupLocationIdWithHttpInfo($warehouse_id, $location)
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseLocation';
        $request = $this->warehouseLookupLocationIdRequest($warehouse_id, $location);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftWarehouseLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseLookupLocationIdAsync
     *
     * 
     *
     * @param  int $warehouse_id (required)
     * @param  string $location (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseLookupLocationIdAsync($warehouse_id, $location)
    {
        return $this->warehouseLookupLocationIdAsyncWithHttpInfo($warehouse_id, $location)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseLookupLocationIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $warehouse_id (required)
     * @param  string $location (required)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseLookupLocationIdAsyncWithHttpInfo($warehouse_id, $location)
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseLocation';
        $request = $this->warehouseLookupLocationIdRequest($warehouse_id, $location);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseLookupLocationId'
     *
     * @param  int $warehouse_id (required)
     * @param  string $location (required)
     *
     * @throws InvalidArgumentException
     * @return Request
     */
    protected function warehouseLookupLocationIdRequest($warehouse_id, $location)
    {
        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling warehouseLookupLocationId'
            );
        }
        // verify the required parameter 'location' is set
        if ($location === null || (is_array($location) && count($location) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location when calling warehouseLookupLocationId'
            );
        }

        $resourcePath = '/api/Warehouse/{WarehouseId}/Location/LookupLocationId';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($location !== null) {
            $queryParams['Location'] = ObjectSerializer::toQueryValue($location);
        }

        // path params
        if ($warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'WarehouseId' . '}',
                ObjectSerializer::toPathValue($warehouse_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseStockMovement
     *
     * @param  int $action action (required)
     * @param  MintsoftWarehouseBookStockRequest $request request (required)
     *
     * @return MintsoftCommonToolkitResult
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseStockMovement($action, $request)
    {
        list($response) = $this->warehouseStockMovementWithHttpInfo($action, $request);
        return $response;
    }

    /**
     * Operation warehouseStockMovementWithHttpInfo
     *
     * @param  int $action (required)
     * @param  MintsoftWarehouseBookStockRequest $request (required)
     *
     * @return array of \Swagger\Client\Model\MintsoftCommonToolkitResult, HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseStockMovementWithHttpInfo($action, $request)
    {
        $returnType = '\Swagger\Client\Model\MintsoftCommonToolkitResult';
        $request = $this->warehouseStockMovementRequest($action, $request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftCommonToolkitResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseStockMovementAsync
     *
     * 
     *
     * @param  int $action (required)
     * @param  MintsoftWarehouseBookStockRequest $request (required)
     *
     * @return PromiseInterface
     *@throws InvalidArgumentException
     */
    public function warehouseStockMovementAsync($action, $request)
    {
        return $this->warehouseStockMovementAsyncWithHttpInfo($action, $request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseStockMovementAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $action (required)
     * @param  MintsoftWarehouseBookStockRequest $request (required)
     *
     * @return PromiseInterface
     *@throws InvalidArgumentException
     */
    public function warehouseStockMovementAsyncWithHttpInfo($action, $request)
    {
        $returnType = '\Swagger\Client\Model\MintsoftCommonToolkitResult';
        $request = $this->warehouseStockMovementRequest($action, $request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseStockMovement'
     *
     * @param  int $action (required)
     * @param  MintsoftWarehouseBookStockRequest $request (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function warehouseStockMovementRequest($action, $request)
    {
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $action when calling warehouseStockMovement'
            );
        }
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $request when calling warehouseStockMovement'
            );
        }

        $resourcePath = '/api/Warehouse/StockMovement';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($action !== null) {
            $queryParams['Action'] = ObjectSerializer::toQueryValue($action);
        }


        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseStockMovements
     *
     * Get a List of Stock Movements that have happened in a warehouse e.g. moving stock from one location to another
     *
     * @param  int $warehouse_id ID of the warehouse (required)
     * @param  int $product_id Product ID - Optional (optional)
     * @param  int $page_no Page No - Default 1 (optional)
     * @param  int $limit Max number of results to return - Default 100 - Max 100 (optional)
     * @param  DateTime $since_date filter to only get results since a certain date - useful last 24 hours etc (optional)
     *
     * @return MintsoftWarehouseAPIDTOStockMovementDTO[]
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseStockMovements($warehouse_id, $product_id = null, $page_no = null, $limit = null, $since_date = null)
    {
        list($response) = $this->warehouseStockMovementsWithHttpInfo($warehouse_id, $product_id, $page_no, $limit, $since_date);
        return $response;
    }

    /**
     * Operation warehouseStockMovementsWithHttpInfo
     *
     * Get a List of Stock Movements that have happened in a warehouse e.g. moving stock from one location to another
     *
     * @param  int $warehouse_id ID of the warehouse (required)
     * @param  int $product_id Product ID - Optional (optional)
     * @param  int $page_no Page No - Default 1 (optional)
     * @param  int $limit Max number of results to return - Default 100 - Max 100 (optional)
     * @param  DateTime $since_date filter to only get results since a certain date - useful last 24 hours etc (optional)
     *
     * @return array of \Swagger\Client\Model\MintsoftWarehouseAPIDTOStockMovementDTO[], HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseStockMovementsWithHttpInfo($warehouse_id, $product_id = null, $page_no = null, $limit = null, $since_date = null)
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseAPIDTOStockMovementDTO[]';
        $request = $this->warehouseStockMovementsRequest($warehouse_id, $product_id, $page_no, $limit, $since_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftWarehouseAPIDTOStockMovementDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseStockMovementsAsync
     *
     * Get a List of Stock Movements that have happened in a warehouse e.g. moving stock from one location to another
     *
     * @param  int $warehouse_id ID of the warehouse (required)
     * @param  int $product_id Product ID - Optional (optional)
     * @param  int $page_no Page No - Default 1 (optional)
     * @param  int $limit Max number of results to return - Default 100 - Max 100 (optional)
     * @param  DateTime $since_date filter to only get results since a certain date - useful last 24 hours etc (optional)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseStockMovementsAsync($warehouse_id, $product_id = null, $page_no = null, $limit = null, $since_date = null)
    {
        return $this->warehouseStockMovementsAsyncWithHttpInfo($warehouse_id, $product_id, $page_no, $limit, $since_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseStockMovementsAsyncWithHttpInfo
     *
     * Get a List of Stock Movements that have happened in a warehouse e.g. moving stock from one location to another
     *
     * @param  int $warehouse_id ID of the warehouse (required)
     * @param  int $product_id Product ID - Optional (optional)
     * @param  int $page_no Page No - Default 1 (optional)
     * @param  int $limit Max number of results to return - Default 100 - Max 100 (optional)
     * @param  DateTime $since_date filter to only get results since a certain date - useful last 24 hours etc (optional)
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function warehouseStockMovementsAsyncWithHttpInfo($warehouse_id, $product_id = null, $page_no = null, $limit = null, $since_date = null)
    {
        $returnType = '\Swagger\Client\Model\MintsoftWarehouseAPIDTOStockMovementDTO[]';
        $request = $this->warehouseStockMovementsRequest($warehouse_id, $product_id, $page_no, $limit, $since_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseStockMovements'
     *
     * @param  int $warehouse_id ID of the warehouse (required)
     * @param  int $product_id Product ID - Optional (optional)
     * @param  int $page_no Page No - Default 1 (optional)
     * @param  int $limit Max number of results to return - Default 100 - Max 100 (optional)
     * @param  DateTime $since_date filter to only get results since a certain date - useful last 24 hours etc (optional)
     *
     * @throws InvalidArgumentException
     * @return Request
     */
    protected function warehouseStockMovementsRequest($warehouse_id, $product_id = null, $page_no = null, $limit = null, $since_date = null)
    {
        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling warehouseStockMovements'
            );
        }

        $resourcePath = '/api/Warehouse/{warehouseId}/StockMovements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($product_id !== null) {
            $queryParams['productId'] = ObjectSerializer::toQueryValue($product_id);
        }
        // query params
        if ($page_no !== null) {
            $queryParams['pageNo'] = ObjectSerializer::toQueryValue($page_no);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($since_date !== null) {
            $queryParams['sinceDate'] = ObjectSerializer::toQueryValue($since_date);
        }

        // path params
        if ($warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseId' . '}',
                ObjectSerializer::toPathValue($warehouse_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation warehouseUpdateWarehouseTransfer
     *
     * Update WarehouseTransfer Details
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     * @param  MintsoftWarehouseAPIWarehouseTransfer $warehouse_transfer  (required)
     *
     * @return MintsoftCommonToolkitResult
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseUpdateWarehouseTransfer($id, $warehouse_transfer)
    {
        list($response) = $this->warehouseUpdateWarehouseTransferWithHttpInfo($id, $warehouse_transfer);
        return $response;
    }

    /**
     * Operation warehouseUpdateWarehouseTransferWithHttpInfo
     *
     * Update WarehouseTransfer Details
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     * @param  MintsoftWarehouseAPIWarehouseTransfer $warehouse_transfer  (required)
     *
     * @return array of \Swagger\Client\Model\MintsoftCommonToolkitResult, HTTP status code, HTTP response headers (array of strings)
     *@throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function warehouseUpdateWarehouseTransferWithHttpInfo($id, $warehouse_transfer)
    {
        $returnType = '\Swagger\Client\Model\MintsoftCommonToolkitResult';
        $request = $this->warehouseUpdateWarehouseTransferRequest($id, $warehouse_transfer);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MintsoftCommonToolkitResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation warehouseUpdateWarehouseTransferAsync
     *
     * Update WarehouseTransfer Details
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     * @param  MintsoftWarehouseAPIWarehouseTransfer $warehouse_transfer  (required)
     *
     * @return PromiseInterface
     *@throws InvalidArgumentException
     */
    public function warehouseUpdateWarehouseTransferAsync($id, $warehouse_transfer)
    {
        return $this->warehouseUpdateWarehouseTransferAsyncWithHttpInfo($id, $warehouse_transfer)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation warehouseUpdateWarehouseTransferAsyncWithHttpInfo
     *
     * Update WarehouseTransfer Details
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     * @param  MintsoftWarehouseAPIWarehouseTransfer $warehouse_transfer  (required)
     *
     * @return PromiseInterface
     *@throws InvalidArgumentException
     */
    public function warehouseUpdateWarehouseTransferAsyncWithHttpInfo($id, $warehouse_transfer)
    {
        $returnType = '\Swagger\Client\Model\MintsoftCommonToolkitResult';
        $request = $this->warehouseUpdateWarehouseTransferRequest($id, $warehouse_transfer);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'warehouseUpdateWarehouseTransfer'
     *
     * @param  int $id ID of the WarehouseTransfer (required)
     * @param  MintsoftWarehouseAPIWarehouseTransfer $warehouse_transfer  (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function warehouseUpdateWarehouseTransferRequest($id, $warehouse_transfer)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling warehouseUpdateWarehouseTransfer'
            );
        }
        // verify the required parameter 'warehouse_transfer' is set
        if ($warehouse_transfer === null || (is_array($warehouse_transfer) && count($warehouse_transfer) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $warehouse_transfer when calling warehouseUpdateWarehouseTransfer'
            );
        }

        $resourcePath = '/api/WarehouseTransfer/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($warehouse_transfer)) {
            $_tempBody = $warehouse_transfer;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'ab');
            if (!$options[RequestOptions::DEBUG]) {
                throw new RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
